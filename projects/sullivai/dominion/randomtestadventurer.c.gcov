        -:    0:Source:randomtestadventurer.c
        -:    0:Graph:randomtestadventurer.gcno
        -:    0:Data:randomtestadventurer.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Aimee Sullivan
        -:    2:// CS 362-400 Assignment 4
        -:    3:// 14 May 2017
        -:    4:// randomtestadventurer.c
        -:    5:// Random tests for adventurer card
        -:    6:// Structure of code is based on testDrawCard.c from dominion project code 
        -:    7:
        -:    8:
        -:    9:#include "dominion.h"
        -:   10:#include "dominion_helpers.h"
        -:   11:#include <string.h>
        -:   12:#include <stdio.h>
        -:   13:#include <assert.h>
        -:   14:#include "rngs.h"
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:#define TESTCARD "adventurer"
        -:   18:// http://stackoverflow.com/a/12989329
        -:   19:#define ASSERT2(xy,MSG) do {\
        -:   20:!(xy) ? printf("     TEST FAILED: %s\n",MSG) : printf("TEST PASSED: %s\n",MSG);\
        -:   21:} while(0)
        -:   22:
        -:   23:// ---------------------test do or do not have to shuffle to look for more cards
        -:   24:// reveal n cards from deck til 2 treasure found
        -:   25:// ----------------------test 0,1,2,3 treasure in deck
        -:   26:// +2 treasure in hand if 2 treasure found
        -:   27:// +1 treasure if only 1 treasure in deck
        -:   28:// 0 treasure if no treasure in deck <---- test 
        -:   29:// ----------------------
        -:   30:// no change to others state
        -:   31:// no change to supply
        -:   32://
        -:   33:
        -:   34:
        -:   35:
function checkPlayAdventurer called 2000 returned 100% blocks executed 87%
     2000:   36:int checkPlayAdventurer(struct gameState *post, int p){
        -:   37:    char msg[1024];
        -:   38:    int i;
     2000:   39:    int preTreasureCount = 0; 
     2000:   40:    int preTreasureHand = 0;
     2000:   41:    int postTreasureCount = 0; 
     2000:   42:    int postTreasureHand = 0;
        -:   43:    struct gameState pre;
     2000:   44:    memcpy(&pre, post, sizeof(struct gameState));
        -:   45:
        -:   46:
   497626:   47:    for (i = 0; i < pre.handCount[p]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   495626:   48:        if (pre.hand[p][i] == copper || pre.hand[p][i] == silver || pre.hand[p][i] == gold){
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
    57242:   49:            preTreasureHand++;
        -:   50:        }
        -:   51:    }
   497856:   52:    for (i = 0; i < pre.deckCount[p]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   495856:   53:        if (pre.deck[p][i] == copper || pre.deck[p][i] == silver || pre.deck[p][i] == gold){
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
    56788:   54:            preTreasureCount++;
        -:   55:        }
        -:   56:    }
   508702:   57:    for (i = 0; i < pre.discardCount[p]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   506702:   58:        if (pre.discard[p][i] == copper || pre.discard[p][i] == silver || pre.discard[p][i] == gold){
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
    58704:   59:            preTreasureCount++;
        -:   60:        }
        -:   61:    }
        -:   62:    
        -:   63:
        -:   64:
        -:   65://    printf("PRE: treasures in discard & deck: %d in hand: %d\n",preTreasureCount, preTreasureHand);
        -:   66:
        -:   67:    //printf("PRE: p %d HC %d DeC %d DiC %d\n",p, pre.handCount[p], pre.deckCount[p], pre.discardCount[p]);
        -:   68:
        -:   69:    
     2000:   70:    play_Adventurer(post, p);
call    0 returned 100%
        -:   71:    
   501623:   72:    for (i = 0; i < post->handCount[p]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   499623:   73:        if (post->hand[p][i] == copper || post->hand[p][i] == silver || post->hand[p][i] == gold){
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
    61239:   74:            postTreasureHand++;
        -:   75:        }
        -:   76:    }
   478903:   77:    for (i = 0; i < post->deckCount[p]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   476903:   78:        if (post->deck[p][i] == copper || post->deck[p][i] == silver || post->deck[p][i] == gold){
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
    54665:   79:            postTreasureCount++;
        -:   80:        }
        -:   81:    }
   521212:   82:    for (i = 0; i < post->discardCount[p]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
   519212:   83:        if (post->discard[p][i] == copper || post->discard[p][i] == silver || post->discard[p][i] == gold){
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
    56542:   84:            postTreasureCount++;
        -:   85:        }
        -:   86:    }
        -:   87:  
        -:   88:
        -:   89:
        -:   90://    printf("POST: treasures in discard & deck: %d in hand: %d\n",postTreasureCount, postTreasureHand);
        -:   91:
        -:   92://    printf("POST: p %d HC %d DeC %d DiC %d\n",p, post->handCount[p], post->deckCount[p], post->discardCount[p]);
        -:   93:
        -:   94:
     2000:   95:    if (preTreasureCount >= 2){
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     1997:   96:        sprintf(msg,"hand = %d, expected = %d", postTreasureHand, preTreasureHand + 2);
     1997:   97:        ASSERT2(postTreasureHand == preTreasureHand + 2, msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
     1997:   98:        sprintf(msg,"deck = %d, expected = %d", postTreasureCount, preTreasureCount - 2);
     1997:   99:        ASSERT2(postTreasureCount == preTreasureCount - 2, msg);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
call    3 returned 100%
        3:  100:    } else if (preTreasureCount == 1){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  101:        sprintf(msg,"hand = %d, expected = %d", postTreasureHand, preTreasureHand + 1);
        3:  102:        ASSERT2(postTreasureHand == preTreasureHand + 1, msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        3:  103:        sprintf(msg,"deck = %d, expected = %d", postTreasureCount, preTreasureCount - 1);
        3:  104:        ASSERT2(postTreasureCount == preTreasureCount - 1, msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -:  105:    } else {
    #####:  106:        sprintf(msg,"hand = %d, expected = %d", postTreasureHand, preTreasureHand);
    #####:  107:        ASSERT2(postTreasureHand == preTreasureHand, msg);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
    #####:  108:        sprintf(msg,"deck = %d, expected = %d", postTreasureCount, preTreasureCount);
    #####:  109:        ASSERT2(postTreasureCount == preTreasureCount, msg);
branch  0 never executed
branch  1 never executed
call    2 never executed
call    3 never executed
        -:  110:    } 
        -:  111:
        -:  112:
        -:  113://    assert(memcmp(&pre, post, sizeof(struct gameState)) == 0;
        -:  114:
     2000:  115:    return 0;
        -:  116:}
        -:  117:
        -:  118:
        -:  119:
        -:  120:
function main called 1 returned 100% blocks executed 100%
        1:  121:int main(){
        -:  122:    int i, n, p, deckCount, discardCount, handCount;
        1:  123:    int k[10] = {adventurer, council_room, feast, gardens, mine,
        -:  124:                remodel, smithy, village, baron, great_hall};
        -:  125:    struct gameState G;
        1:  126:    printf("Testing play_Adventurer.\n");
call    0 returned 100%
        1:  127:    printf("RANDOM TESTS.\n");
call    0 returned 100%
        1:  128:    SelectStream(2);
call    0 returned 100%
        1:  129:    PutSeed(3);
call    0 returned 100%
        -:  130:
     2001:  131:    for (n = 0; n < 2000; n++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 52602000:  132:        for (i = 0; i < sizeof(struct gameState); i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 52600000:  133:            ((char*)&G)[i] = floor(Random() * 256);
call    0 returned 100%
        -:  134:        }
     2000:  135:        p = floor(Random() * MAX_PLAYERS);
call    0 returned 100%
     2000:  136:        G.deckCount[p] = floor(Random() * MAX_DECK);
call    0 returned 100%
     2000:  137:        G.discardCount[p] = floor(Random() * MAX_DECK);
call    0 returned 100%
     2000:  138:        G.handCount[p] = floor(Random() * MAX_HAND);
call    0 returned 100%
        -:  139:        // Random cards in hand
  1002000:  140:        for (i = 0; i < MAX_HAND; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
  1000000:  141:            G.hand[p][i] = floor(Random() * treasure_map);
call    0 returned 100%
        -:  142:        }
        -:  143:        // Random cards in deck and discard
  1002000:  144:        for (i = 0; i < MAX_DECK; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
  1000000:  145:            G.deck[p][i] = floor(Random() * treasure_map);
call    0 returned 100%
  1000000:  146:            G.discard[p][i] = floor(Random() * treasure_map);
call    0 returned 100%
        -:  147:        }
        -:  148:
        -:  149:
     2000:  150:        checkPlayAdventurer(&G, p);
call    0 returned 100%
        -:  151:    }
        -:  152:
        -:  153:
        -:  154:
        -:  155:
        -:  156:
        1:  157:    return 0;
        -:  158:}
        -:  159:
        -:  160:
        -:  161:
        -:  162:
        -:  163:
        -:  164:
        -:  165:/*
        -:  166:int main() {
        -:  167:    char msg[1024];
        -:  168:    int newCards = 0;
        -:  169:    int discarded = 1;
        -:  170:    //int xtraCoins = 0;
        -:  171:    int shuffledCards = 0;
        -:  172:    int extraBuys = 0;
        -:  173:
        -:  174:    int i,j;
        -:  175:    int handpos = 0, choice1 = 0, choice2 = 0, choice3 = 0, bonus = 0;
        -:  176:    int seed = 1000;
        -:  177:    int numPlayers = 2;
        -:  178:    int thisPlayer = 0;
        -:  179:	struct gameState G, testG;
        -:  180:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:  181:			sea_hag, tribute, smithy, council_room};
        -:  182:
        -:  183:	printf("----------------- Testing Card: %s ----------------\n", TESTCARD);
        -:  184:
        -:  185:	// ----------- TEST 1: no treasures in deck - gain nothing --------------
        -:  186:	printf("TEST 1: no treasures in deck - gain nothing\n");
        -:  187:	// initialize a game state and player cards
        -:  188:    memset(&G,'\0',sizeof(struct gameState));
        -:  189:	initializeGame(numPlayers, k, seed, &G);
        -:  190:    thisPlayer = 0;
        -:  191:    newCards = 0;   
        -:  192:    handpos = 0;
        -:  193:    extraBuys = 0;
        -:  194:    //xtraCoins = 0;
        -:  195:
        -:  196:    // put TESTCARD in player's hand
        -:  197:    G.hand[thisPlayer][handpos] = adventurer;
        -:  198:    // make sure there are no treasures in hand
        -:  199:    for (i = 1; i < G.handCount[thisPlayer]; i++){    
        -:  200:        G.hand[thisPlayer][i] = estate;
        -:  201:    }
        -:  202:    memcpy(&testG, &G, sizeof(struct gameState));
        -:  203:    cardEffect(adventurer, choice1, choice2, choice3, &testG, handpos, &bonus);
        -:  204:    // supply piles
        -:  205:    for (j = 0; j <= treasure_map; j++){
        -:  206:        sprintf(msg,"supply[%d] = %d, expected %d",j,testG.supplyCount[j],G.supplyCount[j]);
        -:  207:        ASSERT2(testG.supplyCount[j] == G.supplyCount[j], msg);
        -:  208:    }
        -:  209:    // hand count
        -:  210:    sprintf(msg,"hand count = %d, expected = %d", testG.handCount[thisPlayer], G.handCount[thisPlayer] - discarded);
        -:  211:    ASSERT2(testG.handCount[thisPlayer] == G.handCount[thisPlayer] - discarded, msg);
        -:  212:    // deck count
        -:  213:    sprintf(msg,"deck count = %d, expected = %d", testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        -:  214:    ASSERT2(testG.deckCount[thisPlayer] == G.deckCount[thisPlayer] - newCards + shuffledCards, msg);
        -:  215:    // discard count
        -:  216:    sprintf(msg,"discard count = %d, expected = %d", testG.discardCount[thisPlayer], G.discardCount[thisPlayer]+discarded);
        -:  217:    ASSERT2(testG.discardCount[thisPlayer] == G.discardCount[thisPlayer]+discarded, msg);
        -:  218:    // buys
        -:  219:    sprintf(msg,"buys = %d, expected = %d", testG.numBuys, G.numBuys + extraBuys);
        -:  220:    ASSERT2(testG.numBuys == G.numBuys + extraBuys, msg);
        -:  221:
        -:  222:
        -:  223:
        -:  224:	// ----------- TEST 2: only 1 treasure in deck - +1 in hand  --------------
        -:  225:	printf("TEST 2: 1 treasure in deck - +1 in hand\n");
        -:  226:	// initialize a game state and player cards
        -:  227:    memset(&G,'\0',sizeof(struct gameState));
        -:  228:	initializeGame(numPlayers, k, seed, &G);
        -:  229:    thisPlayer = 0;
        -:  230:    newCards = 1;   
        -:  231:    handpos = 0;
        -:  232:    extraBuys = 0;
        -:  233:    //xtraCoins = 1;
        -:  234:
        -:  235:    // put TESTCARD in player's hand
        -:  236:    G.hand[thisPlayer][handpos] = adventurer;
        -:  237:    G.hand[thisPlayer][handpos+1] = copper;
        -:  238:    // make sure there is only one treasure in hand
        -:  239:    for (i = 2; i < G.handCount[thisPlayer]; i++){    
        -:  240:        G.hand[thisPlayer][i] = estate;
        -:  241:    }
        -:  242:    memcpy(&testG, &G, sizeof(struct gameState));
        -:  243:    cardEffect(adventurer, choice1, choice2, choice3, &testG, handpos, &bonus);
        -:  244:    // supply piles
        -:  245:    for (j = 0; j <= treasure_map; j++){
        -:  246:        sprintf(msg,"supply[%d] = %d, expected %d",j,testG.supplyCount[j],G.supplyCount[j]);
        -:  247:        ASSERT2(testG.supplyCount[j] == G.supplyCount[j], msg);
        -:  248:    }
        -:  249:    // hand count
        -:  250:    sprintf(msg,"hand count = %d, expected = %d", testG.handCount[thisPlayer], G.handCount[thisPlayer] + newCards - discarded);
        -:  251:    ASSERT2(testG.handCount[thisPlayer] == G.handCount[thisPlayer] + newCards - discarded, msg);
        -:  252:    // deck count
        -:  253:    sprintf(msg,"deck count = %d, expected = %d", testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        -:  254:    ASSERT2(testG.deckCount[thisPlayer] == G.deckCount[thisPlayer] - newCards + shuffledCards, msg);
        -:  255:    // discard count
        -:  256:    sprintf(msg,"discard count = %d, expected = %d", testG.discardCount[thisPlayer], G.discardCount[thisPlayer]+discarded);
        -:  257:    ASSERT2(testG.discardCount[thisPlayer] == G.discardCount[thisPlayer]+discarded, msg);
        -:  258:    // buys
        -:  259:    sprintf(msg,"buys = %d, expected = %d", testG.numBuys, G.numBuys + extraBuys);
        -:  260:    ASSERT2(testG.numBuys == G.numBuys + extraBuys, msg);
        -:  261:
        -:  262:
        -:  263:
        -:  264:
        -:  265:	// ----------- TEST 3: 2 treasures in deck - +2 in hand  --------------
        -:  266:	printf("TEST 3: 2 treasures in deck - +2 in hand\n");
        -:  267:    memset(&G,'\0',sizeof(struct gameState));
        -:  268:	initializeGame(numPlayers, k, seed, &G);
        -:  269:    thisPlayer = 0;
        -:  270:    newCards = 2;   
        -:  271:    handpos = 0;
        -:  272:    extraBuys = 0;
        -:  273:    //xtraCoins = 2;
        -:  274:
        -:  275:    // put TESTCARD in player's hand
        -:  276:    G.hand[thisPlayer][handpos] = adventurer;
        -:  277:    G.hand[thisPlayer][handpos+1] = copper;
        -:  278:    G.hand[thisPlayer][handpos+2] = copper;
        -:  279:    // make sure there is only one treasure in hand
        -:  280:    for (i = 3; i < G.handCount[thisPlayer]; i++){    
        -:  281:        G.hand[thisPlayer][i] = estate;
        -:  282:    }
        -:  283:    memcpy(&testG, &G, sizeof(struct gameState));
        -:  284:    cardEffect(adventurer, choice1, choice2, choice3, &testG, handpos, &bonus);
        -:  285:    // supply piles
        -:  286:    for (j = 0; j <= treasure_map; j++){
        -:  287:        sprintf(msg,"supply[%d] = %d, expected %d",j,testG.supplyCount[j],G.supplyCount[j]);
        -:  288:        ASSERT2(testG.supplyCount[j] == G.supplyCount[j], msg);
        -:  289:    }
        -:  290:    // hand count
        -:  291:    sprintf(msg,"hand count = %d, expected = %d", testG.handCount[thisPlayer], G.handCount[thisPlayer] + newCards - discarded);
        -:  292:    ASSERT2(testG.handCount[thisPlayer] == G.handCount[thisPlayer] + newCards - discarded, msg);
        -:  293:    // deck count
        -:  294:    sprintf(msg,"deck count = %d, expected = %d", testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        -:  295:    ASSERT2(testG.deckCount[thisPlayer] == G.deckCount[thisPlayer] - newCards + shuffledCards, msg);
        -:  296:    // discard count
        -:  297:    sprintf(msg,"discard count = %d, expected = %d", testG.discardCount[thisPlayer], G.discardCount[thisPlayer]+discarded);
        -:  298:    ASSERT2(testG.discardCount[thisPlayer] == G.discardCount[thisPlayer]+discarded, msg);
        -:  299:    // buys
        -:  300:    sprintf(msg,"buys = %d, expected = %d", testG.numBuys, G.numBuys + extraBuys);
        -:  301:    ASSERT2(testG.numBuys == G.numBuys + extraBuys, msg);
        -:  302:    
        -:  303:
        -:  304:
        -:  305:
        -:  306:
        -:  307:
        -:  308:	return 0;
        -:  309:}
        -:  310:
        -:  311:*/
