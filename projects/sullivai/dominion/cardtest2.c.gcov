        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Aimee Sullivan
        -:    2:// CS 362-400 Assignment 3
        -:    3:// 30 April 2017
        -:    4:// cardtest2.c
        -:    5:// Unit tests for adventurer card
        -:    6:// Structure of code is based on cardtest4.c provided in Assignment 3 Assistance 
        -:    7:// in course materials.
        -:    8:
        -:    9:
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include <string.h>
        -:   13:#include <stdio.h>
        -:   14:#include <assert.h>
        -:   15:#include "rngs.h"
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:#define TESTCARD "adventurer"
        -:   19:// http://stackoverflow.com/a/12989329
        -:   20:#define ASSERT2(xy,MSG) do {\
        -:   21:!(xy) ? printf("     TEST FAILED: %s\n",MSG) : printf("TEST PASSED: %s\n",MSG);\
        -:   22:} while(0)
        -:   23:
        -:   24:
function main called 1 returned 100% blocks executed 80%
        1:   25:int main() {
        -:   26:    char msg[1024];
        1:   27:    int newCards = 0;
        1:   28:    int discarded = 1;
        -:   29:    //int xtraCoins = 0;
        1:   30:    int shuffledCards = 0;
        1:   31:    int extraBuys = 0;
        -:   32:
        -:   33:    int i,j;
        1:   34:    int handpos = 0, choice1 = 0, choice2 = 0, choice3 = 0, bonus = 0;
        1:   35:    int seed = 1000;
        1:   36:    int numPlayers = 2;
        1:   37:    int thisPlayer = 0;
        -:   38:	struct gameState G, testG;
        1:   39:	int k[10] = {adventurer, embargo, village, minion, mine, cutpurse,
        -:   40:			sea_hag, tribute, smithy, council_room};
        -:   41:
        1:   42:	printf("----------------- Testing Card: %s ----------------\n", TESTCARD);
call    0 returned 100%
        -:   43:
        -:   44:	// ----------- TEST 1: no treasures in deck - gain nothing --------------
        1:   45:	printf("TEST 1: no treasures in deck - gain nothing\n");
call    0 returned 100%
        -:   46:	// initialize a game state and player cards
        1:   47:    memset(&G,'\0',sizeof(struct gameState));
        1:   48:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        1:   49:    thisPlayer = 0;
        1:   50:    newCards = 0;   
        1:   51:    handpos = 0;
        1:   52:    extraBuys = 0;
        -:   53:    //xtraCoins = 0;
        -:   54:
        -:   55:    // put TESTCARD in player's hand
        1:   56:    G.hand[thisPlayer][handpos] = adventurer;
        -:   57:    // make sure there are no treasures in hand
        5:   58:    for (i = 1; i < G.handCount[thisPlayer]; i++){    
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:   59:        G.hand[thisPlayer][i] = estate;
        -:   60:    }
        1:   61:    memcpy(&testG, &G, sizeof(struct gameState));
        1:   62:    cardEffect(adventurer, choice1, choice2, choice3, &testG, handpos, &bonus);
call    0 returned 100%
        -:   63:    // supply piles
       28:   64:    for (j = 0; j <= treasure_map; j++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:   65:        sprintf(msg,"supply[%d] = %d, expected %d",j,testG.supplyCount[j],G.supplyCount[j]);
       27:   66:        ASSERT2(testG.supplyCount[j] == G.supplyCount[j], msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -:   67:    }
        -:   68:    // hand count
        1:   69:    sprintf(msg,"hand count = %d, expected = %d", testG.handCount[thisPlayer], G.handCount[thisPlayer] - discarded);
        1:   70:    ASSERT2(testG.handCount[thisPlayer] == G.handCount[thisPlayer] - discarded, msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        -:   71:    // deck count
        1:   72:    sprintf(msg,"deck count = %d, expected = %d", testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        1:   73:    ASSERT2(testG.deckCount[thisPlayer] == G.deckCount[thisPlayer] - newCards + shuffledCards, msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        -:   74:    // discard count
        1:   75:    sprintf(msg,"discard count = %d, expected = %d", testG.discardCount[thisPlayer], G.discardCount[thisPlayer]+discarded);
        1:   76:    ASSERT2(testG.discardCount[thisPlayer] == G.discardCount[thisPlayer]+discarded, msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        -:   77:    // buys
        1:   78:    sprintf(msg,"buys = %d, expected = %d", testG.numBuys, G.numBuys + extraBuys);
        1:   79:    ASSERT2(testG.numBuys == G.numBuys + extraBuys, msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -:   80:
        -:   81:
        -:   82:    // ---------------------test do or do not have to shuffle to look for more cards
        -:   83:    //
        -:   84:    //
        -:   85:    // reveal n cards from deck til 2 treasure found
        -:   86:    // ----------------------test 0,1,2,3 treasure in deck
        -:   87:    // +2 treasure in hand if 2 treasure found
        -:   88:    // +1 treasure if only 1 treasure in deck
        -:   89:    // 0 treasure if no treasure in deck <---- test 
        -:   90:    // ----------------------
        -:   91:    // no change to others state
        -:   92:    // no change to supply
        -:   93:    //
        -:   94:
        -:   95:	// ----------- TEST 2: only 1 treasure in deck - +1 in hand  --------------
        1:   96:	printf("TEST 2: 1 treasure in deck - +1 in hand\n");
call    0 returned 100%
        -:   97:	// initialize a game state and player cards
        1:   98:    memset(&G,'\0',sizeof(struct gameState));
        1:   99:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        1:  100:    thisPlayer = 0;
        1:  101:    newCards = 1;   
        1:  102:    handpos = 0;
        1:  103:    extraBuys = 0;
        -:  104:    //xtraCoins = 1;
        -:  105:
        -:  106:    // put TESTCARD in player's hand
        1:  107:    G.hand[thisPlayer][handpos] = adventurer;
        1:  108:    G.hand[thisPlayer][handpos+1] = copper;
        -:  109:    // make sure there is only one treasure in hand
        4:  110:    for (i = 2; i < G.handCount[thisPlayer]; i++){    
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:  111:        G.hand[thisPlayer][i] = estate;
        -:  112:    }
        1:  113:    memcpy(&testG, &G, sizeof(struct gameState));
        1:  114:    cardEffect(adventurer, choice1, choice2, choice3, &testG, handpos, &bonus);
call    0 returned 100%
        -:  115:    // supply piles
       28:  116:    for (j = 0; j <= treasure_map; j++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:  117:        sprintf(msg,"supply[%d] = %d, expected %d",j,testG.supplyCount[j],G.supplyCount[j]);
       27:  118:        ASSERT2(testG.supplyCount[j] == G.supplyCount[j], msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -:  119:    }
        -:  120:    // hand count
        1:  121:    sprintf(msg,"hand count = %d, expected = %d", testG.handCount[thisPlayer], G.handCount[thisPlayer] + newCards - discarded);
        1:  122:    ASSERT2(testG.handCount[thisPlayer] == G.handCount[thisPlayer] + newCards - discarded, msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        -:  123:    // deck count
        1:  124:    sprintf(msg,"deck count = %d, expected = %d", testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        1:  125:    ASSERT2(testG.deckCount[thisPlayer] == G.deckCount[thisPlayer] - newCards + shuffledCards, msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        -:  126:    // discard count
        1:  127:    sprintf(msg,"discard count = %d, expected = %d", testG.discardCount[thisPlayer], G.discardCount[thisPlayer]+discarded);
        1:  128:    ASSERT2(testG.discardCount[thisPlayer] == G.discardCount[thisPlayer]+discarded, msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        -:  129:    // buys
        1:  130:    sprintf(msg,"buys = %d, expected = %d", testG.numBuys, G.numBuys + extraBuys);
        1:  131:    ASSERT2(testG.numBuys == G.numBuys + extraBuys, msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -:  132:
        -:  133:
        -:  134:
        -:  135:
        -:  136:	// ----------- TEST 3: 2 treasures in deck - +2 in hand  --------------
        1:  137:	printf("TEST 3: 2 treasures in deck - +2 in hand\n");
call    0 returned 100%
        1:  138:    memset(&G,'\0',sizeof(struct gameState));
        1:  139:	initializeGame(numPlayers, k, seed, &G);
call    0 returned 100%
        1:  140:    thisPlayer = 0;
        1:  141:    newCards = 2;   
        1:  142:    handpos = 0;
        1:  143:    extraBuys = 0;
        -:  144:    //xtraCoins = 2;
        -:  145:
        -:  146:    // put TESTCARD in player's hand
        1:  147:    G.hand[thisPlayer][handpos] = adventurer;
        1:  148:    G.hand[thisPlayer][handpos+1] = copper;
        1:  149:    G.hand[thisPlayer][handpos+2] = copper;
        -:  150:    // make sure there is only one treasure in hand
        3:  151:    for (i = 3; i < G.handCount[thisPlayer]; i++){    
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2:  152:        G.hand[thisPlayer][i] = estate;
        -:  153:    }
        1:  154:    memcpy(&testG, &G, sizeof(struct gameState));
        1:  155:    cardEffect(adventurer, choice1, choice2, choice3, &testG, handpos, &bonus);
call    0 returned 100%
        -:  156:    // supply piles
       28:  157:    for (j = 0; j <= treasure_map; j++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       27:  158:        sprintf(msg,"supply[%d] = %d, expected %d",j,testG.supplyCount[j],G.supplyCount[j]);
       27:  159:        ASSERT2(testG.supplyCount[j] == G.supplyCount[j], msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -:  160:    }
        -:  161:    // hand count
        1:  162:    sprintf(msg,"hand count = %d, expected = %d", testG.handCount[thisPlayer], G.handCount[thisPlayer] + newCards - discarded);
        1:  163:    ASSERT2(testG.handCount[thisPlayer] == G.handCount[thisPlayer] + newCards - discarded, msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        -:  164:    // deck count
        1:  165:    sprintf(msg,"deck count = %d, expected = %d", testG.deckCount[thisPlayer], G.deckCount[thisPlayer] - newCards + shuffledCards);
        1:  166:    ASSERT2(testG.deckCount[thisPlayer] == G.deckCount[thisPlayer] - newCards + shuffledCards, msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -:  167:    // discard count
        1:  168:    sprintf(msg,"discard count = %d, expected = %d", testG.discardCount[thisPlayer], G.discardCount[thisPlayer]+discarded);
        1:  169:    ASSERT2(testG.discardCount[thisPlayer] == G.discardCount[thisPlayer]+discarded, msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
        -:  170:    // buys
        1:  171:    sprintf(msg,"buys = %d, expected = %d", testG.numBuys, G.numBuys + extraBuys);
        1:  172:    ASSERT2(testG.numBuys == G.numBuys + extraBuys, msg);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
call    3 returned 100%
        -:  173:    
        -:  174:
        -:  175:
        -:  176:
        -:  177:
        -:  178:
        1:  179:	return 0;
        -:  180:}
        -:  181:
        -:  182:
