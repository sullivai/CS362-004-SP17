        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Aimee Sullivan
        -:    2:// CS 362-400 Assignment 3
        -:    3:// 30 April 2017
        -:    4:// unittest3.c
        -:    5:// Unit tests for buyCard() function in dominion.c
        -:    6:// Structure of code is based on testUpdateCoins.c provided in Assignment 3 Assistance 2
        -:    7:// in course materials.
        -:    8:#include "dominion.h"
        -:    9:#include "dominion_helpers.h"
        -:   10:#include <string.h>
        -:   11:#include <stdio.h>
        -:   12:#include <assert.h>
        -:   13:#include "rngs.h"
        -:   14:
        -:   15:
        -:   16:
        -:   17:
        -:   18:
function main called 1 returned 100% blocks executed 100%
        1:   19:int main() {
        -:   20:    char msg[1024];
        -:   21:    int result; 
        1:   22:    int seed = 1000;
        1:   23:    int numPlayer = MAX_PLAYERS;
        -:   24:    int r;
        1:   25:    int k[10] = {adventurer, council_room, feast, gardens, mine, remodel,
        -:   26:                smithy, village, baron, great_hall};
        -:   27:    struct gameState G;
        -:   28:    struct gameState tmp;    
        -:   29:
        1:   30:    memset(&G,'\0',sizeof(struct gameState));
        1:   31:    r = initializeGame(numPlayer,k,seed,&G);
call    0 returned 100%
        -:   32:
        1:   33:    printf("\n\n#####################################################\n");
call    0 returned 100%
        1:   34:    printf("##             TESTING buyCards():                 ##\n");
call    0 returned 100%
        1:   35:    printf("#####################################################\n");
call    0 returned 100%
        -:   36:
        -:   37:    // Test 1: not enough buys
        1:   38:    printf("Test 1: not enough buys\n");
call    0 returned 100%
        -:   39:
        1:   40:    G.numBuys = 0;                  // set buys to 0
        1:   41:    G.supplyCount[estate] = 1;      // ensure there is a card
        1:   42:    G.coins = getCost(estate);      // ensure player has sufficient coin for the card
call    0 returned 100%
        1:   43:    tmp = G;                        // save current info
        1:   44:    result = buyCard(estate,&G);
call    0 returned 100%
        -:   45:
        -:   46:
        -:   47:
        -:   48:    // Test 2: not enough cards
        1:   49:    printf("Test 2: not enough cards\n");
call    0 returned 100%
        1:   50:    G.numBuys = 1;                  // ensure there are enough buys
        1:   51:    G.supplyCount[estate] = 0;      // set card supply to 0
        1:   52:    G.coins = getCost(estate);      // ensure player has sufficient coin for the card
call    0 returned 100%
        1:   53:    tmp = G;                        // save current info
        1:   54:    result = buyCard(estate,&G);
call    0 returned 100%
        -:   55:
        -:   56:
        -:   57:    // Test 3: not enough dosh
        1:   58:    printf("Test 3: not enough coins\n");
call    0 returned 100%
        1:   59:    G.numBuys = 1;                  // ensure there are enough buys
        1:   60:    G.supplyCount[estate] = 1;      // ensure there are enough cards
        1:   61:    G.coins = 0;                    // set player money to 0
        1:   62:    tmp = G;                        // save current info
        1:   63:    result = buyCard(estate,&G);
call    0 returned 100%
        -:   64:
        -:   65:
        -:   66:    // Test 4: buy card, make sure everything is updated correctly
        1:   67:    printf("Test 4: successful buy\n");
call    0 returned 100%
        1:   68:    G.numBuys = 1;                  // ensure there are enough buys
        1:   69:    G.supplyCount[estate] = 1;      // ensure there are enough cards
        1:   70:    G.coins = getCost(estate);      // ensure there is enough money
call    0 returned 100%
        1:   71:    G.discardCount[G.whoseTurn] = 0;  // set discard pile to zero
        1:   72:    tmp = G;                        // save current info
        1:   73:    result = buyCard(estate,&G);
call    0 returned 100%
        -:   74:
        -:   75:
        -:   76:
        1:   77:    return 0;
        -:   78:}
