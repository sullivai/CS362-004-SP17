        -:    0:Source:testScoreFor.c
        -:    0:Graph:testScoreFor.gcno
        -:    0:Data:testScoreFor.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Aimee Sullivan
        -:    2:// CS 362-400 Assignment 3
        -:    3:// 30 April 2017
        -:    4:// unittest1.c
        -:    5:// Unit tests for scoreFor() function in dominion.c
        -:    6:// Structure of code is based on testUpdateCoins.c provided in Assignment 3 Assistance 2
        -:    7:// in course materials.
        -:    8:#include "dominion.h"
        -:    9:#include "dominion_helpers.h"
        -:   10:#include <string.h>
        -:   11:#include <stdio.h>
        -:   12:#include <assert.h>
        -:   13:#include "rngs.h"
        -:   14:
        -:   15:/*
        -:   16:// https://bytes.com/topic/c/answers/524316-help-writing-my-own-assert
        -:   17:#define ASSERT(xy,MSG) do {\
        -:   18:if(!(xy)){\
        -:   19:printf("TEST FAILED: %s\n",MSG);\
        -:   20:} \
        -:   21:}while(0)
        -:   22:*/
        -:   23:
        -:   24:// http://stackoverflow.com/a/12989329
        -:   25:#define ASSERT2(xy,MSG) do {\
        -:   26:!(xy) ? printf("     TEST FAILED: %s\n",MSG) : printf("TEST PASSED: %s\n",MSG);\
        -:   27:} while(0)
        -:   28:
        -:   29:
        -:   30:
function main called 1 returned 100% blocks executed 98%
        1:   31:int main() {
        1:   32:    char msg[1024] = {'\0'};
        -:   33:    int i, p, r, handCount, discardCount,  deckCount, totalCards;
        -:   34:    // Some information needed to initialize game state
        1:   35:    int seed = 1000;
        1:   36:    int numPlayer = MAX_PLAYERS;
        1:   37:    int k[10] = {adventurer, council_room, feast, gardens, mine, remodel,
        -:   38:                smithy, village, baron, great_hall};
        -:   39:    struct gameState G;
        1:   40:    int maxHandCount = 5;
        -:   41:
        -:   42:    // Set up full "decks" of each kind of card that is used in scoring
        -:   43:    int curses[MAX_HAND];
        -:   44:    int estates[MAX_HAND];
        -:   45:    int duchies[MAX_HAND];
        -:   46:    int provinces[MAX_HAND];
        -:   47:    int great_halls[MAX_HAND];
        -:   48:    int gardenses[MAX_HAND];
        -:   49:
        6:   50:    for (i = 0; i < maxHandCount; i++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        5:   51:        curses[i] = curse;
        5:   52:        estates[i] = estate;
        5:   53:        duchies[i] = duchy;
        5:   54:        provinces[i] = province;
        5:   55:        great_halls[i] = great_hall;
        5:   56:        gardenses[i] = gardens;
        -:   57:    }
        -:   58:
        1:   59:    printf("TESTING scoreFor():\n");
call    0 returned 100%
        -:   60:
        1:   61:    p = 0;  // This player
        -:   62:
        -:   63:    // Set up game    
        1:   64:    memset(&G,'\0',sizeof(struct gameState));
        1:   65:    r = initializeGame(numPlayer,k,seed,&G);
call    0 returned 100%
        1:   66:    assert(!r);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   67:
        -:   68:    // Loop to test 0, 1, and more than one of cards
        -:   69:    // Go up to 2 digits total cards to register a score on gardens
        6:   70:    for (handCount = 0; handCount < maxHandCount; handCount++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       30:   71:    for (discardCount = 0; discardCount < maxHandCount; discardCount++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      150:   72:    for (deckCount = 0; deckCount < maxHandCount; deckCount++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:   73:        // Set hand, discard, and deck to be 0 or some # of cards
      125:   74:        G.handCount[p] = handCount;
      125:   75:        G.discardCount[p] = discardCount;
      125:   76:        G.deckCount[p] = deckCount;
      125:   77:        totalCards = G.handCount[p] + G.discardCount[p] + G.deckCount[p];
        -:   78:    
        -:   79:        // Test curse
      125:   80:        memcpy(G.hand[p],curses,sizeof(int)*G.handCount[p]);        
      125:   81:        memcpy(G.discard[p],curses,sizeof(int)*G.discardCount[p]);
      125:   82:        memcpy(G.deck[p],curses,sizeof(int)*G.deckCount[p]);
      125:   83:        sprintf(msg,"CURSE with %d in hand, %d in discard, %d in deck. Score: %d Expected: %d\n", handCount, discardCount, deckCount, scoreFor(p,&G), (-1 * totalCards));
call    0 returned 100%
      125:   84:        ASSERT2(scoreFor(p,&G) == (-1 * totalCards),msg);
call    0 returned 100%
branch  1 taken 42% (fallthrough)
branch  2 taken 58%
call    3 returned 100%
call    4 returned 100%
        -:   85:        //printf("Score for %d curse cards: %d Expected: %d\n", totalCards, scoreFor(p,&G), (-1 * totalCards));
        -:   86:        
        -:   87:        // Test estate
      125:   88:        memcpy(G.hand[p],estates,sizeof(int)*G.handCount[p]);
      125:   89:        memcpy(G.discard[p],estates,sizeof(int)*G.discardCount[p]);
      125:   90:        memcpy(G.deck[p],estates,sizeof(int)*G.deckCount[p]);
      125:   91:        sprintf(msg,"ESTATE with %d in hand, %d in discard, %d in deck. Score: %d Expected: %d\n", handCount, discardCount, deckCount, scoreFor(p,&G), (1 * totalCards));
call    0 returned 100%
      125:   92:        ASSERT2(scoreFor(p,&G) == (1 * totalCards),msg);
call    0 returned 100%
branch  1 taken 40% (fallthrough)
branch  2 taken 60%
call    3 returned 100%
call    4 returned 100%
        -:   93:        //printf("Score for %d estate cards: %d Expected: %d\n", totalCards, scoreFor(p,&G), (1 * totalCards));
        -:   94:    
        -:   95:        // Test duchy
      125:   96:        memcpy(G.hand[p],duchies,sizeof(int)*G.handCount[p]);
      125:   97:        memcpy(G.discard[p],duchies,sizeof(int)*G.discardCount[p]);
      125:   98:        memcpy(G.deck[p],duchies,sizeof(int)*G.deckCount[p]);
      125:   99:        sprintf(msg,"DUCHY with %d in hand, %d in discard, %d in deck. Score: %d Expected: %d\n", handCount, discardCount, deckCount, scoreFor(p,&G), (3 * totalCards));
call    0 returned 100%
      125:  100:        ASSERT2(scoreFor(p,&G) == (3 * totalCards),msg);
call    0 returned 100%
branch  1 taken 40% (fallthrough)
branch  2 taken 60%
call    3 returned 100%
call    4 returned 100%
        -:  101:        //printf("Score for %d duchy cards: %d Expected: %d\n", totalCards, scoreFor(p,&G), (3 * totalCards));
        -:  102:
        -:  103:        // Test province
      125:  104:        memcpy(G.hand[p],provinces,sizeof(int)*G.handCount[p]);
      125:  105:        memcpy(G.discard[p],provinces,sizeof(int)*G.discardCount[p]);
      125:  106:        memcpy(G.deck[p],provinces,sizeof(int)*G.deckCount[p]);
      125:  107:        sprintf(msg,"PROVINCE with %d in hand, %d in discard, %d in deck. Score: %d Expected: %d\n", handCount, discardCount, deckCount, scoreFor(p,&G), (6 * totalCards));
call    0 returned 100%
      125:  108:        ASSERT2(scoreFor(p,&G) == (6 * totalCards),msg);
call    0 returned 100%
branch  1 taken 40% (fallthrough)
branch  2 taken 60%
call    3 returned 100%
call    4 returned 100%
        -:  109:        //printf("Score for %d province cards: %d Expected: %d\n", totalCards, scoreFor(p,&G), (6 * totalCards));
        -:  110:
        -:  111:        // Test great_hall
      125:  112:        memcpy(G.hand[p],great_halls,sizeof(int)*G.handCount[p]);
      125:  113:        memcpy(G.discard[p],great_halls,sizeof(int)*G.discardCount[p]);
      125:  114:        memcpy(G.deck[p],great_halls,sizeof(int)*G.deckCount[p]);
      125:  115:        sprintf(msg,"GREAT_HALL with %d in hand, %d in discard, %d in deck. Score: %d Expected: %d\n", handCount, discardCount, deckCount, scoreFor(p,&G), (1 * totalCards));
call    0 returned 100%
      125:  116:        ASSERT2(scoreFor(p,&G) == (totalCards),msg);
call    0 returned 100%
branch  1 taken 40% (fallthrough)
branch  2 taken 60%
call    3 returned 100%
call    4 returned 100%
        -:  117:        //printf("Score for %d great_hall cards: %d Expected: %d\n", totalCards, scoreFor(p,&G), (1 * totalCards));
        -:  118:
        -:  119:        // Test gardens
      125:  120:        memcpy(G.hand[p],gardenses,sizeof(int)*G.handCount[p]);
      125:  121:        memcpy(G.discard[p],gardenses,sizeof(int)*G.discardCount[p]);
      125:  122:        memcpy(G.deck[p],gardenses,sizeof(int)*G.deckCount[p]);
      125:  123:        sprintf(msg,"GARDEN with %d in hand, %d in discard, %d in deck. Score: %d Expected: %d\n", handCount, discardCount, deckCount, scoreFor(p,&G), (totalCards/10));
call    0 returned 100%
      125:  124:        ASSERT2(scoreFor(p,&G) == (totalCards/10),msg);   
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
call    3 returned 100%
call    4 returned 100%
        -:  125:        //printf("Score for %d gardens cards: %d Expected: %d\n", totalCards, scoreFor(p,&G), (totalCards/10));
        -:  126:    }
        -:  127:    }
        -:  128:    }
        -:  129:
        -:  130:    //printf("All tests passed.\n");
        1:  131:    return 0;
        -:  132:}
