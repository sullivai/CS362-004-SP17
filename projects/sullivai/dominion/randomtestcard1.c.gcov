        -:    0:Source:randomtestcard1.c
        -:    0:Graph:randomtestcard1.gcno
        -:    0:Data:randomtestcard1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Aimee Sullivan
        -:    2:// CS 362-400 Assignment 4
        -:    3:// 14 May 2017
        -:    4:// randomtestcard1.c
        -:    5:// Random tests for mine card
        -:    6:// Structure of code is based on testDrawCard.c from dominion project code 
        -:    7:
        -:    8:
        -:    9:#include "dominion.h"
        -:   10:#include "dominion_helpers.h"
        -:   11:#include <string.h>
        -:   12:#include <stdio.h>
        -:   13:#include <assert.h>
        -:   14:#include <math.h>
        -:   15:#include "rngs.h"
        -:   16:#include <stdlib.h>
        -:   17:
        -:   18:#define TESTCARD "adventurer"
        -:   19:// http://stackoverflow.com/a/12989329
        -:   20:#define ASSERT2(xy,MSG) do {\
        -:   21:!(xy) ? printf("     TEST FAILED: %s\n",MSG) : printf("TEST PASSED: %s\n",MSG);\
        -:   22:} while(0)
        -:   23:
        -:   24:/*
        -:   25:- hand contains 0, 1, 2 treasure cards
        -:   26:- hand contains coppers - get silver
        -:   27:- hand contains silvers - get gold
        -:   28:- num cards in hand is same (-1 to discard?)
        -:   29:- no other state changes except treasure supply maybe
        -:   30:- coins increase
        -:   31:- buys stay same
        -:   32:- correct card (gold or silver) is in trash
        -:   33:- gaincard(s) --> goes into hand
        -:   34:- mine is discarded into trash
        -:   35:choice1 is card to trash
        -:   36:-- test choice1 is treasure card
        -:   37:choice2 is card to gain
        -:   38:-- test choice2 is treasure and valid supply pile
        -:   39:*/
        -:   40:
function checkPlayMine called 200000 returned 100% blocks executed 96%
   200000:   41:int checkPlayMine(struct gameState *post, int p, int handPos, int ch1, int ch2){
        -:   42:    char msg[1024];
        -:   43:    int r; //, i;
        -:   44:
        -:   45:    struct gameState pre;
   200000:   46:    memcpy(&pre, post, sizeof(struct gameState));
        -:   47:
        -:   48:    // PLAY THE CARD    
   200000:   49:    r = play_Mine(post, p, handPos, ch1, ch2);
call    0 returned 100%
        -:   50:
        -:   51:    // bad choice 1
   200000:   52:    if (post->hand[p][ch1] < copper || post->hand[p][ch1] > gold){
branch  0 taken 84% (fallthrough)
branch  1 taken 16%
branch  2 taken 87% (fallthrough)
branch  3 taken 13%
   178168:   53:        sprintf(msg,"Returned choice 1 incorrect type %d, expect 4, 5, or 6.", post->hand[p][ch1]);
   178168:   54:        ASSERT2(r == -1 && (post->hand[p][ch1] < copper || post->hand[p][ch1] > gold) ,msg);
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 82% (fallthrough)
branch  3 taken 18%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 returned 100%
call    7 returned 100%
   178168:   55:        sprintf(msg, "No state change.");
   178168:   56:        ASSERT2(memcmp(&pre, post, sizeof(struct gameState)) == 0,msg);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
call    2 returned 100%
call    3 returned 100%
        -:   57:    }
        -:   58:
        -:   59:    // bad choice 2
   200000:   60:    if (ch2 < copper || ch2 > gold){
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
branch  2 taken 86% (fallthrough)
branch  3 taken 14%
   176818:   61:        sprintf(msg,"Returned choice 2 incorrect type %d, expect 4, 5, or 6.", ch2);
   176818:   62:        ASSERT2(r == -1 && (ch2 < copper || ch2 > gold),msg);
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 82% (fallthrough)
branch  3 taken 18%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 returned 100%
call    7 returned 100%
   176818:   63:        sprintf(msg, "No state change.");
   176818:   64:        ASSERT2(memcmp(&pre, post, sizeof(struct gameState)) == 0,msg);
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
call    2 returned 100%
call    3 returned 100%
        -:   65:    }
        -:   66:
        -:   67:    // choice 2 too expensive
   200000:   68:    if (getCost(post->hand[p][ch1]) + 3 < getCost(ch2)){
call    0 returned 100%
call    1 returned 100%
branch  2 taken 8% (fallthrough)
branch  3 taken 92%
    15195:   69:        sprintf(msg,"Returned card too expensive (cost is %d, limit is %d)",getCost(ch2),getCost(post->hand[p][ch1])+3);
call    0 returned 100%
call    1 returned 100%
    15195:   70:        ASSERT2(r == -1 && getCost(post->hand[p][ch1]) + 3 < getCost(ch2),msg);
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
call    2 returned 100%
call    3 returned 100%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
call    6 returned 100%
call    7 returned 100%
    15195:   71:        sprintf(msg, "No state change.");
    15195:   72:        ASSERT2(memcmp(&pre, post, sizeof(struct gameState)) == 0,msg);
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
call    2 returned 100%
call    3 returned 100%
        -:   73:    }
        -:   74:    
        -:   75:
   200000:   76:    if (r == 0){
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:   77:        // if all OK and card is played, then handcount--, discard++, ch1 supply++, ch2 supply--    
     7300:   78:        sprintf(msg, "POST handcount %d, expected %d.", post->handCount[p],pre.handCount[p]-1);
     7300:   79:        ASSERT2(post->handCount[p] == pre.handCount[p]-1,msg);
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
call    3 returned 100%
     7300:   80:        sprintf(msg, "POST discardcount %d, expected %d.", post->discardCount[p],pre.discardCount[p]+1);
     7300:   81:        ASSERT2(post->discardCount[p] == pre.discardCount[p]+1,msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
     7300:   82:        sprintf(msg, "POST ch1 supply count %d, expected %d.", post->supplyCount[pre.hand[p][ch1]],pre.supplyCount[pre.hand[p][ch1]]+1);
     7300:   83:        ASSERT2(post->supplyCount[pre.hand[p][ch1]] == pre.supplyCount[pre.hand[p][ch1]]+1,msg);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
call    3 never executed
     7300:   84:        sprintf(msg, "POST ch2 supply count %d, expected %d.", post->supplyCount[ch2], pre.supplyCount[ch2]);
     7300:   85:        ASSERT2(post->supplyCount[ch2] == pre.supplyCount[ch2]-1,msg);
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
call    3 returned 100%
        -:   86:    }
        -:   87:
   200000:   88:    return 0;
        -:   89:}
        -:   90:
        -:   91:
        -:   92:
        -:   93:
function main called 1 returned 100% blocks executed 100%
        1:   94:int main(){
        -:   95:    int i, n, p, handPos, ch1, ch2;
        -:   96:    struct gameState G;
        1:   97:    printf("Testing play_Mine.\n");
call    0 returned 100%
        1:   98:    printf("RANDOM TESTS.\n");
call    0 returned 100%
        1:   99:    SelectStream(2);
call    0 returned 100%
        1:  100:    PutSeed(3);
call    0 returned 100%
        -:  101:
   200001:  102:    for (n = 0; n < 200000; n++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  103:        // set up game state with random info
5260200000:  104:        for (i = 0; i < sizeof(struct gameState); i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
5260000000:  105:            ((char*)&G)[i] = floor(Random() * 256);
call    0 returned 100%
        -:  106:        }
   200000:  107:        p = floor(Random() * MAX_PLAYERS);
call    0 returned 100%
   200000:  108:        G.whoseTurn = p;
   200000:  109:        G.deckCount[p] = floor(Random() * MAX_DECK);
call    0 returned 100%
   200000:  110:        G.discardCount[p] = floor(Random() * MAX_DECK);
call    0 returned 100%
   200000:  111:        G.handCount[p] = floor(Random() * MAX_HAND);
call    0 returned 100%
   200000:  112:        G.playedCardCount = floor(Random() * MAX_DECK);
call    0 returned 100%
        -:  113:        // Random cards in hand
 50118100:  114:        for (i = 0; i < G.handCount[p]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 49918100:  115:            G.hand[p][i] = floor(Random() * treasure_map);
call    0 returned 100%
        -:  116:        }
        -:  117:        // Random cards in deck 
 50095736:  118:        for (i = 0; i < G.deckCount[p]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 49895736:  119:            G.deck[p][i] = floor(Random() * treasure_map);
call    0 returned 100%
        -:  120:        }
        -:  121:        // Random cards in discard 
 50009756:  122:        for (i = 0; i < G.discardCount[p]; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 49809756:  123:            G.discard[p][i] = floor(Random() * treasure_map);
call    0 returned 100%
        -:  124:        }
        -:  125:        // Random cards in played 
 50021649:  126:        for (i = 0; i < G.playedCardCount; i++){
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 49821649:  127:            G.playedCards[i] = floor(Random() * treasure_map);
call    0 returned 100%
        -:  128:        }
        -:  129:
        -:  130:/*        // every 100 turns no treasures
        -:  131:        if (n % 100 == 0){
        -:  132:            for (i = 0; i < G.handCount[p]; i++){
        -:  133:                if (G.hand[p][i] >= copper && G.hand[p][i] <= gold){
        -:  134:                    G.hand[p][i] = estate;
        -:  135:                } 
        -:  136:            }
        -:  137:            for (i = 0; i < G.deckCount[p]; i++){
        -:  138:                if (G.deck[p][i] >= copper && G.deck[p][i] <= gold){
        -:  139:                    G.deck[p][i] = estate;
        -:  140:                } 
        -:  141:            }
        -:  142:            for (i = 0; i < G.discardCount[p]; i++){
        -:  143:                if (G.discard[p][i] >= copper && G.discard[p][i] <= gold){
        -:  144:                    G.discard[p][i] = estate;
        -:  145:                } 
        -:  146:            }
        -:  147:        }
        -:  148:*/
        -:  149:        // pick a random handPos for card to be played
   200000:  150:        handPos = floor(Random() * (G.handCount[p] - 1));
call    0 returned 100%
        -:  151:        
        -:  152:        // pick a random card to trash from hand
   200000:  153:        ch1 = floor(Random() * (G.handCount[p] - 1));
call    0 returned 100%
        -:  154:
        -:  155:        // pick a random card to gain from supply
   200000:  156:        ch2 = floor(Random() * treasure_map);
call    0 returned 100%
        -:  157:
   200000:  158:        printf("player %d, handcount %d, handpos %d, ch1 %d, cost %d, ch2 %d, cost %d\n",p, G.handCount[p], handPos, G.hand[p][ch1], getCost(G.hand[p][ch1]), ch2, getCost(ch2));
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
        -:  159:
        -:  160:        // test card play
   200000:  161:        checkPlayMine(&G, p, handPos, ch1, ch2);
call    0 returned 100%
        -:  162:    }
        -:  163:
        1:  164:    return 0;
        -:  165:}
