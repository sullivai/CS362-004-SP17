        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// Aimee Sullivan
        -:    2:// CS 362-400 Assignment 3
        -:    3:// 30 April 2017
        -:    4:// unittest2.c
        -:    5:// Unit tests for isGameOver() function in dominion.c
        -:    6:// Structure of code is based on testUpdateCoins.c provided in Assignment 3 Assistance 2
        -:    7:// in course materials.
        -:    8:#include "dominion.h"
        -:    9:#include "dominion_helpers.h"
        -:   10:#include <string.h>
        -:   11:#include <stdio.h>
        -:   12:#include <assert.h>
        -:   13:#include "rngs.h"
        -:   14:
        -:   15:
        -:   16:// http://stackoverflow.com/a/12989329
        -:   17:#define ASSERT2(xy,MSG) do {\
        -:   18:!(xy) ? printf("     TEST FAILED: %s\n",MSG) : printf("TEST PASSED: %s\n",MSG);\
        -:   19:} while(0)
        -:   20:
        -:   21:
        -:   22:
function main called 1 returned 100% blocks executed 91%
        1:   23:int main() {
        1:   24:    char msg[1024] = {'\0'};
        -:   25:    int i, r, gameover;
        -:   26:    // stuff to set up game state
        1:   27:    int seed = 1000;
        1:   28:    int numPlayer = MAX_PLAYERS;
        1:   29:    int k[10] = {adventurer, council_room, feast, gardens, mine, remodel,
        -:   30:                smithy, village, baron, great_hall};
        -:   31:    struct gameState G;
        -:   32:
        1:   33:    printf("\n\n#####################################################\n");
call    0 returned 100%
        1:   34:    printf("##             TESTING isGameOver():               ##\n");
call    0 returned 100%
        1:   35:    printf("#####################################################\n");
call    0 returned 100%
        -:   36:    
        -:   37:    // TEST 1: No provinces, game is over
        1:   38:    printf("\nTest 1: provinces condition\n");
call    0 returned 100%
        -:   39:
        -:   40:    // Initialize game
        1:   41:    memset(&G,'\0',sizeof(struct gameState));
        1:   42:    r = initializeGame(numPlayer,k,seed,&G);
call    0 returned 100%
        1:   43:    assert(!r);  
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   44:
        -:   45:    // Test 1, 0, -1 provinces
        4:   46:    for (i = 1; i >= -1; i--){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        3:   47:        G.supplyCount[province] = i;
        3:   48:        gameover = isGameOver(&G);
call    0 returned 100%
        3:   49:        sprintf(msg,"Provinces: %d, game is %sover",i,(gameover ? "" : "not "));
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:   50:        //ASSERT2(isGameOver(&G) != i, msg);
        -:   51:    }
        -:   52:    
        -:   53:    // TEST 2: Provinces but 3 or more supply piles are empty, game is over
        1:   54:    printf("\nTest 2: provinces but empty supply piles condition\n");
call    0 returned 100%
        -:   55:
        -:   56:    // Loop through all supply cards and 0 out three piles at a time, then check status
       26:   57:    for (i = 0; i <= treasure_map-2; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       25:   58:        memset(&G,'\0',sizeof(struct gameState));
       25:   59:        r = initializeGame(numPlayer,k,seed,&G);
call    0 returned 100%
       25:   60:        assert(!r); 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   61:        // skip zeroing province pile
       25:   62:        if(i == province-2 || i == province-1 || i == province) continue;
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 96% (fallthrough)
branch  3 taken 4%
branch  4 taken 4% (fallthrough)
branch  5 taken 96%
       22:   63:        G.supplyCount[i] = 0;
       22:   64:        G.supplyCount[i+1] = 0;
       22:   65:        G.supplyCount[i+2] = 0;
       22:   66:        gameover = isGameOver(&G);
call    0 returned 100%
       22:   67:        sprintf(msg,"pile %d = %d; pile %d = %d; pile %d = %d; game is %sover",i,G.supplyCount[i],i+1,G.supplyCount[i+1],i+2,G.supplyCount[i+2],(gameover ? "" : "not "));
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
        -:   68:        //ASSERT2(isGameOver(&G),msg);
        -:   69:    }
        -:   70: 
        -:   71:    
        -:   72:    // TEST 3: Provinces and 2 or fewer supply piles are empty, games is not over
        1:   73:    printf("\nTest 3: provinces and 2 or fewer empty supply piles condition\n");
call    0 returned 100%
        -:   74:
        -:   75:    // Loop through all supply cards and 0 out two piles at a time, then check status
       26:   76:    for (i = 0; i <= treasure_map-2; i++){
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       25:   77:        memset(&G,'\0',sizeof(struct gameState));
       25:   78:        r = initializeGame(numPlayer,k,seed,&G);
call    0 returned 100%
       25:   79:        assert(!r); 
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:   80:        // skip zeroing province pile
       25:   81:        if(i == province-1 || i == province) continue;
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 4% (fallthrough)
branch  3 taken 96%
       23:   82:        G.supplyCount[i] = 0;
       23:   83:        G.supplyCount[i+1] = 0;
       23:   84:        gameover = isGameOver(&G);
call    0 returned 100%
       23:   85:        sprintf(msg,"pile %d = %d; pile %d = %d; pile %d = %d; game is %sover",i,G.supplyCount[i],i+1,G.supplyCount[i+1],i+2,G.supplyCount[i+2],(gameover ? "" : "not "));
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   86:        //ASSERT2(!isGameOver(&G),msg);
        -:   87:    }
        -:   88:
        -:   89:
        1:   90:    return 0;
        -:   91:}
